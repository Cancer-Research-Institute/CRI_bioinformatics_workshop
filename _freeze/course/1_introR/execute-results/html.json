{
  "hash": "1a215458a6b618603049517476297613",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to R\"\nformat:\n  html:\n    code-link: true\n    other-links:\n      - text: Lecture Slides\n        href: https://github.com/Cancer-Research-Institute/CRI_bioinformatics_workshop/blob/main/course/slides/CRI%20Bioinformatics%20Bootcamp%202025%20Day%201AM.pdf\nengine: knitr\n---\n\n\n# RStudio: Introduction and Interface Orientation\n\n[RStudio](https://www.rstudio.com/) is an integrated development environment (IDE) for R. It provides a user-friendly interface for coding, debugging, and data analysis. We use RStudio for its convenience and powerful features.\n\n## Interface Orientation\n\n- **Console**: Where you can directly type and execute R commands.\n- **Script Editor**: Where you write and save your R scripts.\n- **Environment and History**: Displays objects in your workspace and your command history.\n- **Files and Plots**: Helps manage files and view plots.\n- **Packages**: Shows installed packages and allows you to install and load new ones.\n\n# Working Directory\n\nThe working directory is the folder where R looks for files. It's important to set it correctly for consistency across Windows and Mac.\n\n```R\n# Get the current working directory\ncurrent_dir <- getwd()\nprint(paste(\"Current directory:\", current_dir))\n\n# List files in the current directory\nfiles <- list.files()\nprint(\"Files in the current directory:\")\nprint(files)\n\n# Change the current directory\nnew_dir <- \"path/to/new/directory\"\nsetwd(new_dir)\nprint(paste(\"Changed directory to:\", new_dir))\n```\n\n# Objects, Variables, and Environment\n\nIn R, objects are created to store data. Variables are used to name and reference these objects. The environment is the current workspace where objects and variables are stored.\n\n## Numeric\n```R\n# Numeric variable\nnum_var <- 10\nprint(num_var)  # Output: 10\n\n# Arithmetic operations\nresult <- num_var * 2\nprint(result)  # Output: 20\n```\n\n## Character\n```R\n# Character variable\nchar_var <- \"Hello, World!\"\nprint(char_var)  # Output: Hello, World!\n\n# Concatenation\nnew_string <- paste(char_var, \"This is R programming.\")\nprint(new_string)  # Output: Hello, World! This is R programming.\n```\n\n## Integer\n```R\n# Integer variable\nint_var <- 20L  # The 'L' suffix indicates an integer\nprint(int_var)  # Output: 20\n\n# Integer arithmetic\nresult <- int_var / 5\nprint(result)  # Output: 4\n```\n\n## Matrices\n\nGene expression data from single-cell RNA sequencing (scRNA-seq) experiments is typically represented as a matrix, where rows correspond to genes and columns correspond to cells. Each cell contains the expression level of a gene, quantified as counts or normalized values. In R, there are several matrix data types commonly used for storing and manipulating gene expression data:\n\n- **Matrix (`matrix`)**: The basic matrix data type in R. It is a two-dimensional array with elements of the same data type.\n\n- **Data Frame (`data.frame`)**: A special type of matrix where columns can contain different data types (e.g., numeric, character, factor). Data frames are commonly used for storing tabular data, including gene expression matrices with additional metadata.\n\n- **Sparse Matrix (`Matrix` package)**: A matrix format optimized for storing large, sparse datasets with many zero values. It conserves memory and speeds up computation for large-scale analyses.\n\n### Basic Operations on Matrix Objects\n\n#### Creating a Matrix:\n```R\n# Create a matrix with random values\nmat <- matrix(rnorm(20), nrow = 4, ncol = 5)\n```\n\nMatrix operations\n```R\nelement <- mat[1, 2]\nprint(element)\n\n# Calculate row sums\nrow_sums <- rowSums(mat)\nprint(row_sums)\n\n# Calculate column sums\ncol_sums <- colSums(mat)\nprint(col_sums)\n\n# Create another matrix\nmat2 <- matrix(rnorm(20), nrow = 5, ncol = 4)\nprint(mat2)\n\n# Perform matrix multiplication\nmat_mult <- mat %*% mat2\nprint(mat_mult)\n\n# Transpose the matrix\nmat_transpose <- t(mat)\nprint(mat_transpose)\n\n# Select the first two rows\nfirst_two_rows <- mat[1:2, ]\nprint(first_two_rows)\n\n# Select the first three columns\nfirst_three_cols <- mat[, 1:3]\nprint(first_three_cols)\n```\n\n## Logical\n```R\n# Logical variable\nlogical_var <- TRUE\nprint(logical_var)  # Output: TRUE\n\n# Logical operations\nresult <- logical_var & FALSE\nprint(result)  # Output: FALSE\n\n\n# Logical operations\na <- TRUE\nb <- FALSE\n\n# AND operation\nresult_and <- a & b\nprint(result_and)  # Output: FALSE\n\n# OR operation\nresult_or <- a | b\nprint(result_or)   # Output: TRUE\n\n# NOT operation\nresult_not <- !a\nprint(result_not)  # Output: FALSE\n\n# Comparison operators\nx <- 5\ny <- 10\n\n# Greater than\nresult_gt <- x > y\nprint(result_gt)  # Output: FALSE\n\n# Less than\nresult_lt <- x < y\nprint(result_lt)  # Output: TRUE\n\n# Equal to\nresult_eq <- x == y\nprint(result_eq)  # Output: FALSE\n\n# Not equal to\nresult_neq <- x != y\nprint(result_neq)  # Output: TRUE\n```\n\n# Conditional Statment\n\n```R\nx <- 3\nif (x > 5) {\n  print(\"x is greater than 5\")\n} else if (x == 5) {\n  print(\"x is equal to 5\")\n} else {\n  print(\"x is less than 5\")\n}\n```\n\n# Loops\n\n## `while`\n\nA while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The loop executes the loop body as long as the condition remains true. When the condition becomes false, the loop terminates.\n\n```R\n# Example of a while loop\nx <- 1\nwhile (x <= 5) {\n  print(x)\n  x <- x + 1\n}\n```\n\n#### Considerations:\n - Ensure that the loop has an exit condition that is guaranteed to be met to avoid infinite loops.\n - Avoid complex conditions that can make the loop difficult to read and maintain.\n - Use while loops when the number of iterations is not known before the loop starts, as opposed to for loops, which are better suited for a known number of iterations.\n - Manage loop variables carefully to ensure they are updated correctly and the loop condition changes as expected.\n\n## `for`\n\nA for loop is a control flow statement used in many programming languages to repeat a block of code multiple times. It is particularly useful for iterating over sequences (like lists, arrays, or strings) and executing a piece of code for each element in the sequence.\n\n```R\n# Example of a for loop\nfor (i in 1:5) {\n  print(i)\n}\n```\n\n##### Considerations\n - Ensure the loop has a condition that eventually becomes false to prevent infinite loops.\n - Be careful with the loop's scope and variables to avoid unintended side effects.\n\n## `apply`\n\nThe apply() function in R is a powerful tool for applying a function to the rows or columns of a matrix or data frame. It is particularly useful for performing operations across a dataset without needing to write explicit loops. The syntax for apply() is:\n\n\n```R\napply(X, margin, function, ...)\n\n# X: This is the array or matrix on which you want to apply the function.\n# margin: A value that specifies whether to apply the function over rows (1), columns (2), or both (c(1, 2)).\n# function: The function you want to apply to each row or column.\n```\n\nTo calculate the sum of each row in a matrix:\n```R\n# Create a matrix\nmy_matrix <- matrix(1:9, nrow=3)\n\n# Apply sum function across rows\nrow_sums <- apply(my_matrix, 1, sum)\nprint(row_sums)\n```\n\nTo find the mean of each column in a data frame:\n```R\n# Create a data frame\ndf <- data.frame(a = c(1, 2, 3), b = c(4, 5, 6))\n\n# Apply mean function across columns\ncolumn_means <- apply(df, 2, mean)\nprint(column_means)\n```\n\n\n### `sapply` and `lappy`\n\n- `lapply()` returns a list, regardless of the output of each application of the function.\n- `sapply()` attempts to simplify the result into a vector or matrix if possible. If simplification is not possible, it returns a list similar to `lapply()`.\n\nSuppose you have a list of numerical vectors and you want to compute the sum of each vector. Here's how you could use lapply():\n```R\n# Define a list of vectors\nnum_list <- list(c(1, 2, 3), c(4, 5), c(6, 7, 8, 9))\n\n# Use lapply to apply the sum function\nlist_sums <- lapply(num_list, sum)\nprint(list_sums)\n```\n\nUsing the same list of numerical vectors, if you use sapply() to compute the sum, the function will try to simplify the output into a vector:\n\n```R\n# Use sapply to apply the sum function\nvector_sums <- sapply(num_list, sum)\nprint(vector_sums)\n```\n\nWhen to Use Each\n \n - `lapply()`: When you need the robustness of a list output, especially when dealing with heterogeneous data or when the function can return variable lengths or types.\n - `sapply()`: When you are working with homogeneous data and prefer a simplified output such as a vector or matrix, assuming the lengths and types are consistent across elements.\n\n# String Manipulation\n\nThe `stringr` package in R simplifies these tasks with easy-to-use functions that can handle typical string operations.\n\n## Finding Patterns\n\nFinding specific sequences or motifs within biological sequences is a common task.\n```R\nlibrary(stringr)\nsequence <- \"ATGCGTACGTTGACA\"\nmotif <- \"CGT\"\nstr_locate(sequence, motif)\n```\n\n## Replacing Substrings\n\nModifying sequences by replacing specific nucleotides or amino acids.\n\n```R\ndna_sequence <- \"ATGCGTACGTTGACT\"\nrna_sequence <- str_replace_all(dna_sequence, \"T\", \"U\")\nprint(rna_sequence)\n```\n\n## Substring Extraction\n\nExtracting parts of sequences, such as cutting out genes or regions of interest.\n\n```R\nextracted_sequence <- str_sub(sequence, 3, 8)\nprint(extracted_sequence)\n```\n\n## Length Calculation\n\nDetermining the length of sequences.\n```R\nsequence_length <- str_length(sequence)\nprint(sequence_length)\n```\n\n## Case Conversion\n\nConverting uppercase to lowercase, or vice versa.\n\n```R\nsequence_upper <- str_to_upper(sequence)\nprint(sequence_upper)\n```\n\n## Splitting Strings\n\nSplitting sequences into arrays, useful for reading fasta files or analyzing codons.\n```R\ncodons <- str_sub(sequence, seq(1, str_length(sequence), by = 3), seq(3, str_length(sequence), by = 3))\nprint(codons)\n```\n\n**Bonus Challenge:** What if our sequence length wasn't a multiple of three? For an example of how to approach this situation please check out the [Bonus challenge].\n\n## Counting Specific Characters\n\nCounting occurrences of specific nucleotides or amino acids.\n```R\nguanine_count <- str_count(sequence, \"G\")\nprint(guanine_count)\n```\n\n# Packages in R\n\nA package is a collection of R functions, data, and compiled code. Packages provide a way to organize and share code, making it easier for users to access specific tools and functions.\n\n## Tidyverse\n\n[Tidyverse](https://www.tidyverse.org/) is a collection of R packages designed for data science. It includes packages like `ggplot2` for data visualization and `dplyr` for data manipulation.\n\n### Tidyverse Data Frames\n\nTidyverse is a collection of R packages designed for data science, developed with a focus on simplicity, consistency, and ease of use. One of the key components of Tidyverse is the concept of tidy data frames.\n\nA tidyverse data frame is a rectangular table-like structure where:\n\n- Each row represents an observation.\n- Each column represents a variable.\n- Each cell holds a single value.\n\n### Principles of Tidy Data:\n1. **Each variable forms a column**: In a tidy data frame, each variable is placed in its own column. This makes it easy to work with the dataset as each variable is explicitly represented.\n\n2. **Each observation forms a row**: Each row corresponds to a distinct observation, entity, or case. This makes it straightforward to perform operations on individual observations.\n\n3. **Each type of observational unit forms a table**: Different types of data should be stored in separate tables, with relationships between tables represented using unique identifiers.\n\n### Why Tidy Data Frames are Important:\n- **Ease of Analysis**: Tidy data frames make it easier to perform data manipulation, visualization, and analysis using Tidyverse packages such as `dplyr`, `ggplot2`, and `tidyr`.\n  \n- **Readability and Interpretability**: Tidy data frames have a consistent structure, making it easier for others to understand and interpret your data.\n\n- **Efficiency**: Tidy data frames facilitate efficient and concise code, reducing the complexity of data manipulation tasks.\n\n### Tidyverse Packages for Data Manipulation:\n- **dplyr**: Provides a grammar of data manipulation for data frames, enabling easy filtering, selecting, mutating, summarizing, and arranging of data.\n  \n- **tidyr**: Offers tools for reshaping and tidying messy datasets, such as `gather()` and `spread()` functions for converting between wide and long formats.\n  \n- **ggplot2**: Allows for the creation of sophisticated data visualizations using a layered grammar of graphics.\n\n```R\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\n\n# Example dataset\ndata <- data.frame(\n  ID = 1:3,\n  Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n  Math = c(90, 85, 95),\n  Science = c(88, 92, 89)\n)\n\n# Original dataset\nprint(\"Original dataset:\")\nprint(data)\n\n# Tidy the dataset using gather() function from tidyr\ntidy_data <- gather(data, Subject, Score, -ID, -Name)\n\n# Tidied dataset\nprint(\"Tidied dataset:\")\nprint(tidy_data)\n```\n\n## Selecting Columns\n\nSelecting columns allows you to choose specific columns from your dataset. It helps you focus on the variables of interest and ignore the rest.\n\n```R\nselected_data <- select(data, ID, Math)\nprint(selected_data)\n```\n\n## Filtering Rows\n\nFiltering rows allows you to subset your dataset based on specific conditions. It helps you extract only the rows that meet certain criteria.\n\n```R\n# Filtering rows based on conditions\nfiltered_data <- filter(data, Math > 90)\nprint(filtered_data)\n```\n\n## Summarizing Data\n\nSummarizing data involves calculating summary statistics or aggregating data to get a concise overview of your dataset. It helps you understand the overall characteristics of your data.\n\n```R\nsummary_data <- summarize(data, \n                          Mean_Math = mean(Math), \n                          Mean_Science = mean(Science))\nprint(summary_data)\n```\n\n## Sorting (Arranging)\n\nArranging rows involves sorting your dataset based on the values of one or more columns. It helps you reorder your data for better visualization or analysis.\n\n```R\narranged_data <- arrange(data, desc(Math))\nprint(arranged_data)\n```\n\n## Mutate\n\nThe mutate() function in the dplyr package is essential for transforming data frames in R. It allows you to add new columns to a data frame or modify existing ones, using existing data. mutate() is part of the tidyverse, a collection of R packages designed for data science that makes data manipulation, exploration, and visualization easy and intuitive.\n\n### Adding columns\nCalculating the GC content of DNA sequences.\n```R\nlibrary(dplyr)\nlibrary(stringr)\n\n# Sample data\nsequences <- tibble(\n  id = c(\"seq1\", \"seq2\", \"seq3\"),\n  dna = c(\"ATGCGC\", \"GCGTACGT\", \"ATATATAT\")\n)\n\n# Calculate GC content\nsequences <- sequences %>%\n  mutate(gc_content = (str_count(dna, \"[GC]\") / str_length(dna)) * 100)\n\nprint(sequences)\n```\n\n### Replacing existing columns\n\nTranscription of DNA sequences into RNA sequences involves replacing thymine (T) with uracil (U).\n\n```R\n# Convert DNA to RNA\nsequences <- sequences %>%\n  mutate(rna = str_replace_all(dna, \"T\", \"U\"))\n\nprint(sequences)\n```\n\n\n### Multiple Transformations\n\nIdentifying potential neoantigens by finding motifs associated with high mutation frequencies or specific mutation patterns.\n\n```R\n# Sample DNA sequences\nsequences <- tibble(\n  id = c(\"seq1\", \"seq2\", \"seq3\"),\n  dna = c(\"ATGCGCATC\", \"GCGTACGTAGT\", \"ATATATATAT\")\n)\n\n# Assume a simple motif that might indicate a neoantigen\nmotif = \"ATG\"\n\n# Annotate sequences with potential neoantigen presence\nsequences <- sequences %>%\n  mutate(\n    start_position = str_locate(dna, motif)[,1],\n    is_neoantigen_candidate = ifelse(start_position > 0 & str_count(dna, \"[GC]\") / str_length(dna) > 0.5, \"Yes\", \"No\")\n  )\n\nprint(sequences)\n```\n\n# Functions\n\n## Definition\nFunctions (`function`) in R perform specific tasks. They take input (arguments), perform operations, and return output.\n\n```R\nfunction_name <- function(argument1, argument2, ...) {\n  # Function body\n  # Perform operations\n  # Return a value (optional)\n}\n```\n - function_name: Name of the function.\n - argument1, argument2, ...: Arguments passed to the function (optional).\n - Function body: Code block where you define what the function should do.\n - Return a value (optional): Use the return() statement to specify what the function should return (optional).\n\nHere, we define a function and call it!\n```R\n# Define a function to calculate the square of a number\nsquare <- function(x) {\n  return(x^2)\n}\n\n# Call the function\nresult <- square(5)\nprint(result)  # Output: 25\n```\n\n## Example\n\nLet's bring together concepts by writing the function `analyze_tcr_data`.\n\n\nThe function will:\n\n - Filter T cell sequences based on a specified length threshold.\n - Sort the remaining data by clonality in descending order to identify the most prevalent TCRs.\n - Create a new column that indicates the presence of a specific motif within the TCR sequence, a common task in sequence analysis.\n\n\n```R\nlibrary(dplyr)\nlibrary(stringr)\n\n# Define the function\nanalyze_tcr_data <- function(tcr_tibble, length_threshold) {\n  # Validate input\n  if (!inherits(tcr_tibble, \"tbl_df\")) {\n    stop(\"Input must be a tibble.\")\n  }\n  \n  # Filter TCR sequences longer than the threshold and sort by clonality\n  filtered_and_sorted <- tcr_tibble %>%\n    filter(str_length(tcr_sequence) > length_threshold) %>%\n    arrange(desc(clonality))\n  \n  # Add a column to indicate the presence of a specific motif (e.g., 'CASS')\n  enhanced_tcr_tibble <- filtered_and_sorted %>%\n    mutate(has_motif = if_else(str_detect(tcr_sequence, \"CASS\"), \"Yes\", \"No\"))\n  \n  # Return the transformed tibble\n  return(enhanced_tcr_tibble)\n}\n\n# Example usage\n# Assuming a tibble with TCR sequences and clonality metrics\ntcr_data <- tibble(\n  tcr_sequence = c(\"CASSLGGTDTQYF\", \"CASSLGDETQYF\", \"CASSLG\", \"CASSEGTDTQYF\"),\n  clonality = c(0.25, 0.15, 0.05, 0.55)\n)\n\n# Apply the function with a length threshold of 10\nresult_data <- analyze_tcr_data(tcr_data, 10)\nprint(result_data)\n```\n\nExplanation\n\n - Validation: The function starts by checking if the provided data is a tibble to ensure type safety.\n - Filtering: Uses `filter()` to retain only TCR sequences longer than the specified length_threshold.\n - Sorting: Uses `arrange()` to sort the data by clonality in descending order.\n - String Manipulation: Adding has_motif Column: Uses `mutate()` combined with `str_detect()` from the stringr package to add a column that indicates whether each TCR sequence contains the motif \"CASS\".\n - Return Value: Outputs a tibble that's been filtered, sorted, and enhanced with additional string-based analysis.\n\n# Reading in Files\n\nReading files is a crucial part of data analysis. R provides functions for reading various file formats.\n\n```R\n# Read a CSV file into a data frame\ndata <- read.csv(\"path/to/your/file.csv\")\n\n# View the structure of the data frame\nprint(\"Structure of the data frame:\")\nprint(str(data))\n\n# View the first few rows of the data frame\nprint(\"First few rows of the data frame:\")\nprint(head(data))\n```\n\n# Additional Exercises\n\n```R\n# Load the iris dataset (saved as iris in base R)\nprac_data <- iris\n\n# What variables are measured in the iris dataset?\n# Hint: What do colnames(), str(), and summary() tell you about the data frame\n# CODE YOUR ANSWER HERE\n\n# How many sets of measurements were taken in the iris dataset?\n# Hint: What is the difference between nrow(), ncol(), dim(), and length()\n# CODE YOUR ANSWER HERE\n\n# What are the three unique types of species analyzed in the iris dataset?\n# Hint: How can unique() and table() be used to understand iris$Species\n# CODE YOUR ANSWER HERE\n\n# Filter the iris dataset to only those that are of the Species setosa\n# Save this dataframe as the variable \"setosa\"\n# CODE YOUR ANSWER HERE\n\n# What is the average sepal width of irises that are of the Species setosa?\n# Hint: Summary values of numeric vectors can be evaluated using min(), median(), max(), and summary()\n# CODE YOUR ANSWER HERE\n\n# Add a new column to setosa called \"short_petal\" that indicates TRUE if the \n# Petal.Length is less than 5 and FALSE if the Petal.Length is at least 5\n# CODE YOUR ANSWER HERE\n\n# Create a function called \"score\" that checks whether the value of a numeric vector \n# (input) is greater than the mean of all of the values, and returns a character vector\n# with \"high\" for the values greater than the mean and \"low\" for the values\n# less than the mean.\n\n# Create a new column for setosa called \"sepal_length_score\" that uses \"high\" and\n# \"low\" to indicate which values are greater than or less than the mean.\n# Hint: How can you use the function you create \n\n# Advanced: What does the following block of code do\niris %>%\n  group_by(Species) %>%\n  count()\n\n# Advanced: Do you have a *.csv, *.tsv, or *.txt file of your own that you\n# can add to your project?\n# Hint: There is an \"Upload\" option in the Files pane where you can add a file\n# that is present on your own computer. You can then read the file into your\n# environment.\n\n\n```\n\n## Bonus challenge\n\nIf our sequence isn't length three, this code will throw an error because the function expects a sequence that is a multiple of 3:\n\n```R\nlibrary(stringr)\nsequence <- \"ATGCGTACGTTGAC\" # Length 14\n# sequence <- \"ATGCGTACGTTGACA\" # Length 15\n\ncodons <- str_sub(sequence, seq(1, str_length(sequence), by = 3), seq(3, str_length(sequence), by = 3))\n\n#> Error in `str_sub()`:\n#> ! Can't recycle `string` (size 5) to match `end` (size 4).\n#> Run `rlang::last_trace()` to see where the error occurred.\n```\n\nCan you try to code up a solution to this problem? \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**HINT**\"}\n# We can use the modulus operator \"%%\". It yields the remainder when the first operand is divided by the second.\n\n15 %% 3 \n#> [1] 0\n\n14 %% 3\n#> [1] 2\n```\n:::\n\n\nHere are a few options for how to solve this (only peek after trying yourself). \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Show me the solution**\"}\nsequence <- \"ATGCGTACGTTGAC\" # Length 14\n\n# sequence <- \"ATGCGTACGTTGACA\" # Length 15\n\n# Option 1: Check for length 3 and make sure before running the code, otherwise print a warning.\n\nsequence_length <- nchar(sequence) # Get sequence length\n\nif (sequence_length %% 3 != 0) {\n  print(paste(\"Error! The sequence is length:\", sequence_length))\n  codons <- \"ERROR\"\n} else {\n  codons <- str_sub(string = sequence, \n  start = seq(1, str_length(sequence), by = 3), \n  end = seq(3, str_length(sequence), by = 3))\n}\n\nprint(codons)\n\n# Option 2: Add N to the sequence to make in a multiple of 3, and then any seqeuence will run properly.\n\nif (sequence_length %% 3 != 0) {\n  leftover <- 3 - nchar(sequence) %% 3\n  \n  leftover_n <- paste(rep(\"N\", leftover), collapse = \"\")\n  \n  sequence <- paste0(sequence, leftover_n)\n}\n\ncodons <- str_sub(sequence, seq(1, str_length(sequence), by = 3), seq(3, str_length(sequence), by = 3))\n\nprint(codons)\n```\n:::\n",
    "supporting": [
      "1_introR_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}