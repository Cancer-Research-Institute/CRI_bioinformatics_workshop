{
  "hash": "e4df90bef7b45d8dc39e329885ce9e4b",
  "result": {
    "markdown": "---\ntitle: \"Intro to Spatial Data\"\nexecute:\n  warning: false\nformat:\n  html:\n    code-link: true\n    toc-depth: 3\n    other-links:\n      - text: Lecture Slides\n        href: https://github.com/Cancer-Research-Institute/CRI_bioinformatics_workshop/blob/main/course/slides/\nengine: knitr\n---\n\n\n# Introduction\n\nIn this notebook we will introduce loading, pre- and post-processing, clustering and cell typing for a VisiumHD dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SeuratWrappers)\nlibrary(Banksy)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(ggplot2)\nlibrary(readxl)\nlibrary(Seurat)\n```\n:::\n\n\n# Loading data\n\nHere we load an already processed object downloaded from 10X genomics:\n\n-   [VisiumHD Example Dataset: Breast DCIS](https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-human-breast-cancer-ffpe-if)\n\n::: callout-warning\nThe full dataset is quite large, and so the next few code chunks are for demonstration purposes only. We will subset this object, which is what you will load later. Skip to the [hands-on section](#hands-on-section) to load the zoomed in object and proceed.\n:::\n\nExpand the code below to see how you would load and pre-process output from VisiumHD before saving a Seurat object. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Set the directory where the data are\ndirs <- c(\"raw_data/Visium_HD_Breast_dataset_CRI/Output_Files/\")\n\n# Path to save individual processed Seurat objects\nouts_path <- \"objects/\"\n\n# Load individual sample\nobject <- Load10X_Spatial(data.dir = dirs, bin.size = c(8))\n\n# Assign metadata\nobject$orig.ident <- \"Visium_10X_breast_cancer\"\nobject$sample_name <- \"Visium_DCIS\"\nIdents(object) <- \"sample_name\"\n\n# Compute mitochondrial percentage\nobject[[\"MT.percent\"]] <- PercentageFeatureSet(object, pattern = \"^MT-\")\n\n# Perform some initial data normalization and find variable features\nDefaultAssay(object) <- \"Spatial.008um\"\nobject <- NormalizeData(object)\n\n# Save the full object\nsaveRDS(object, file.path(outs_path, \"Visium_DCIS.rds\"))\n```\n:::\n\n\n\nFor the purposes of the tutorial we subset the dataset to smaller section of tissue to save size and computational time.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Coordinates to zoom in to\ncoordinates <- GetTissueCoordinates(object)\n\nmin_x <- 14000\nmax_x <- 17500\nmin_y <- 15000\nmax_y <- 18500\n\nsubset_condition <- (coordinates$x > min_x) & (coordinates$y > min_y) & (coordinates$y < max_y) & (coordinates$x < max_x)\n\nDCIS_zoom <- subset(object, cells = which(subset_condition))\n\n# Remove completely empty bins\nDCIS_zoom <- DCIS_zoom[, DCIS_zoom$nCount_Spatial.008um > 0]\n\n# Update the seurat object to ensure object validity\nDCIS_zoom <- UpdateSeuratObject(DCIS_zoom)\n\nsaveRDS(DCIS_zoom, file = \"objects/Visium_DCIS_zoomed.rds\")\n```\n:::\n\n\n# Hands On Section {#hands-on-section}\n\nWe will start the hands on section here by loading the zoomed in VisiumHD tissue section prior to further downstream and plotting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject <- readRDS(\"objects/Visium_DCIS_zoomed.rds\")\n```\n:::\n\n\nLet's take a look at this object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n18085 features across 19823 samples within 1 assay \nActive assay: Spatial.008um (18085 features, 0 variable features)\n 2 layers present: counts, data\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\nLet's also set up some defaults that can be used throughout the downstream processing\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This sets the size of points in the spatial plots\npt_size_factor <- 13\n\n# Color defaults for clusters\ndistinct_palette <- c(\n  \"0\" = \"#1f77b4\",\n  \"1\" = \"#ff7f0e\",\n  \"2\" = \"#2ca02c\",\n  \"3\" = \"#d62728\",\n  \"4\" = \"#9467bd\",\n  \"5\" = \"#8c564b\",\n  \"6\" = \"#ff99cc\",\n  \"7\" = \"#7f7f7f\",\n  \"8\" = \"#bcbd22\",\n  \"9\" = \"#17becf\",\n  \"10\" = \"#393b79\",\n  \"11\" = \"#637939\",\n  \"12\" = \"#8c6d31\"\n)\n\n# Cell type colors\ncelltype_cols <- c(\n  \"CD8.T.cells\" = \"green4\",\n  \"CD4.T.cells\" = \"blue\",\n  \"B.cell\" = \"#F781BF\",\n  \"Plasma\" = \"#FF7F00\",\n  \"Monocytes\" = \"purple\",\n  \"Macrophages\" = \"#b15928\",\n  \"DCs\" = \"#17becf\",\n  \"Endothelial.cells\" = \"#E41A1C\",\n  \"CAF\" = \"#984ea3\",\n  \"Basal_Myoepithelial\" = \"mediumseagreen\",\n  \"Epithelial.cells\" = \"#fdbf6f\",\n  \"Fibroblasts\" = \"darkgrey\",\n  \"Luminal.progenitor\" = \"navy\",\n  \"Luminal.mature\" = \"#bcbd22\",\n  \"Tumor\" = \"magenta\",\n  \"NK.cells\" = \"lavender\",\n  \"Mast.cells\" = \"green2\",\n  \"Adipocytes\" = \"lightgrey\",\n  \"Other\" = \"lightgrey\"\n)\n```\n:::\n\n\nWe can plot some quality metrics like total counts, genes detected, and mitochondrial gene count per bin:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts_violin <- VlnPlot(\n  object,\n  features = \"nCount_Spatial.008um\",\n  pt.size = 0,\n  raster = FALSE\n) +\n  NoLegend()\n\ncounts_spatial <- SpatialFeaturePlot(\n  object,\n  features = \"nCount_Spatial.008um\",\n  pt.size.factor = pt_size_factor,\n  image.alpha = 0.8,\n  alpha = c(1, 1)\n) +\n  theme(legend.position = \"right\")\n\ngenes_violin <- VlnPlot(\n  object,\n  features = \"nFeature_Spatial.008um\",\n  pt.size = 0,\n  raster = FALSE\n) +\n  NoLegend()\n\ngenes_spatial <- SpatialFeaturePlot(\n  object,\n  features = \"nFeature_Spatial.008um\",\n  pt.size.factor = pt_size_factor,\n  image.alpha = 0.8,\n  alpha = c(1, 1)\n) +\n  theme(legend.position = \"right\")\n\nmt_violin <- VlnPlot(\n  object,\n  features = \"MT.percent\",\n  pt.size = 0,\n  raster = FALSE\n) +\n  NoLegend()\n\nmt_spatial <- SpatialFeaturePlot(\n  object,\n  features = \"MT.percent\",\n  pt.size.factor = pt_size_factor,\n  max.cutoff = \"q99\",\n  image.alpha = 0.8,\n  alpha = c(1, 1)\n) +\n  theme(legend.position = \"right\")\n\n# Combine the plots using 'patchwork'\np0 <- (counts_violin | counts_spatial) /\n  (genes_violin | genes_spatial) /\n  (mt_violin | mt_spatial)\np0\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n## Quality filtering\n\nHere we filter to keep only bins with less than 25% mitochondrial counts, 10 total counts, and 10 total genes detected per 8um bin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# UMI and Gene Threshold\nobject$QCFilter <- ifelse(\n  object$MT.percent < 25 &\n    object$nCount_Spatial.008um > 10 &\n    object$nFeature_Spatial.008um > 10,\n  yes = \"Keep\", no = \"Remove\"\n)\n\ntable(object$QCFilter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  Keep Remove \n 19102    721 \n```\n:::\n:::\n\n\nTake a look at the low quality bins using `SpatialDimPlot()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- SpatialDimPlot(object,\n  group.by = \"QCFilter\",\n  pt.size.factor = pt_size_factor,\n  image.alpha = 0.2,\n  alpha = c(1, 0.2)\n) +\n  guides(fill = guide_legend(override.aes = list(size = 4)))\np1\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-8-1.png){width=480}\n:::\n:::\n\n\nFilter our object for only high quality bins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep_cells <- colnames(object)[object$QCFilter == \"Keep\"]\nobject <- subset(object, cells = keep_cells)\n\n# We find variable features and scale after quality filtering\nobject <- FindVariableFeatures(object)\nobject <- ScaleData(object)\n```\n:::\n\n\nNow take a look at our object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n18085 features across 19102 samples within 1 assay \nActive assay: Spatial.008um (18085 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\n\n## Clustering\n\n### Banksy\n\nAbove, we normalized the counts, and found the variable features as you would in a normal scRNA analysis workflow using Seurat. However, in spatial data, we use clustering methods like [Banksy](https://prabhakarlab.github.io/Banksy/) which make use of the spatial information when defining clusters. Check the documentation for the [`RunBanksy()`](https://rdrr.io/github/satijalab/seurat-wrappers/man/RunBanksy.html) command for more information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run Banksy\nobject <- RunBanksy(object,\n  lambda = 0.8,\n  assay = \"Spatial.008um\",\n  slot = \"data\",\n  features = \"variable\",\n  k_geom = 24,\n  verbose = TRUE\n)\n```\n:::\n\n\nIf we look at the object we now see that the active assay is set to `BANKSY`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n22085 features across 19102 samples within 2 assays \nActive assay: BANKSY (4000 features, 0 variable features)\n 2 layers present: data, scale.data\n 1 other assay present: Spatial.008um\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\n\nNow we `RunPCA()` on the `BANKSY` assay.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject <- RunPCA(object,\n  assay = \"BANKSY\",\n  reduction.name = \"pca.banksy\",\n  features = rownames(object),\n  npcs = 20\n)\n```\n:::\n\n\nLook at the elbow plot to help determine the `k` for `RunPCA()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nElbowPlot(object, reduction = \"pca.banksy\")\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nSimilar to conventional scRNA analysis, we now run `FindNeighbors()`, `FindClusters()`, and then `RunUMAP()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject <- FindNeighbors(object,\n  reduction = \"pca.banksy\",\n  dims = 1:15\n)\n\nobject <- FindClusters(object,\n  cluster.name = \"banksy_cluster\",\n  resolution = 0.3\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 19102\nNumber of edges: 496475\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9067\nNumber of communities: 8\nElapsed time: 1 seconds\n```\n:::\n\n```{.r .cell-code}\nobject <- RunUMAP(object,\n  reduction = \"pca.banksy\",\n  reduction.name = \"umap.banksy\",\n  return.model = T,\n  dims = 1:15\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nIdents(object) <- \"banksy_cluster\"\n\np2 <- SpatialDimPlot(object,\n  group.by = \"banksy_cluster\",\n  pt.size.factor = pt_size_factor,\n  label = F,\n  label.size = 5,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_fill_manual(values = distinct_palette) +\n  ggtitle(\"Banksy Neighborhood Clustering\") +\n  theme(\n    legend.position = \"right\",\n    legend.key.size = unit(0.5, \"cm\")\n  ) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nDefaultAssay(object) <- \"BANKSY\"\nIdents(object) <- \"banksy_cluster\"\n\np3 <- DimPlot(object,\n  reduction = \"umap.banksy\",\n  label = TRUE,\n  label.size = 2,\n  raster = FALSE\n) +\n  scale_color_manual(values = distinct_palette) +\n  ggtitle(\"Banksy Neighborhood Clustering\") +\n  theme(\n    legend.position = \"right\",\n    aspect.ratio = 1,\n    legend.key.size = unit(0.5, \"cm\")\n  ) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nfinal_plot <- wrap_plots(p2, p3, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n### Sketching and Projection\n\nSeurat V5 introduced the concept of [data sketching](https://satijalab.org/seurat/articles/seurat5_sketch_analysis). Briefly, this approach will 'sketch' a representative subset of your dataset (importantly preserving rare cell types), prior to performing dimensional reduction, clustering, and computing a UMAP. It then 'projects' the rest of your data into this reduced space so that the complete dataset can be utilized in downstream analysis.\n\n::: callout-note\nIn our example dataset we already subset to \\~20,000 bins, so sketching here is just for demonstration of the code. In full VisiumHD datasets, which typically contain 500k or more bins, this is almost always required as the processing will take a very long time otherwise, and the results are typically comparable.\n:::\n\n::: callout-warning\nUnlike `Banksy`, this type of clustering is *not* spatially aware! It treats the data as you would a conventional scRNA dataset, not taking into account the spatial localization of different cell types. This isn't inherently a bad thing, but it is important to know when interpreting the results.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDefaultAssay(object) <- \"Spatial.008um\"\n\n# Sketch the dataset\nobject <- SketchData(\n  object = object,\n  ncells = 10000,\n  features = VariableFeatures(object),\n  method = \"LeverageScore\",\n  sketched.assay = \"sketch\"\n)\n```\n:::\n\n\nNow if we look at the object we see that the `sketch` assay is now active\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n40170 features across 19102 samples within 3 assays \nActive assay: sketch (18085 features, 2000 variable features)\n 2 layers present: counts, data\n 2 other assays present: Spatial.008um, BANKSY\n 2 dimensional reductions calculated: pca.banksy, umap.banksy\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\n\nWe proceed analyzing as we typically would for an scRNA dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# switch analysis to sketched cells\nDefaultAssay(object) <- \"sketch\"\n\n# Perform the clustering workflow\nobject <- FindVariableFeatures(object)\nobject <- ScaleData(object)\nobject <- RunPCA(object, assay = \"sketch\", reduction.name = \"pca.sketch\")\nElbowPlot(object, reduction = \"pca.sketch\")\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nobject <- FindNeighbors(object,\n  assay = \"sketch\",\n  reduction = \"pca.sketch\",\n  dims = 1:15\n)\nobject <- FindClusters(object,\n  cluster.name = \"seurat_cluster.sketched\",\n  resolution = 0.2\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10000\nNumber of edges: 285667\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8901\nNumber of communities: 3\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\nobject <- RunUMAP(object,\n  reduction = \"pca.sketch\",\n  reduction.name = \"umap.sketch\",\n  return.model = T,\n  dims = 1:15\n)\n```\n:::\n\n\nNow that we have run the processing on the 'sketched' data subset, we project the rest of the data into this space\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject <- ProjectData(\n  object = object,\n  assay = \"Spatial.008um\",\n  full.reduction = \"full.pca.sketch\",\n  sketched.assay = \"sketch\",\n  sketched.reduction = \"pca.sketch\",\n  umap.model = \"umap.sketch\",\n  dims = 1:15,\n  refdata = list(seurat_cluster.projected = \"seurat_cluster.sketched\")\n)\nobject\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n40170 features across 19102 samples within 3 assays \nActive assay: sketch (18085 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 2 other assays present: Spatial.008um, BANKSY\n 6 dimensional reductions calculated: pca.banksy, umap.banksy, pca.sketch, umap.sketch, full.pca.sketch, full.umap.sketch\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDefaultAssay(object) <- \"sketch\"\nIdents(object) <- \"seurat_cluster.sketched\"\n\np4 <- DimPlot(object, \n              reduction = \"umap.sketch\", \n              label = T, \n              raster = F) +\n  scale_color_manual(values = distinct_palette) +\n  ggtitle(\"Sketched clustering (10,000 cells)\") +\n  theme(\n    legend.key.size = unit(0.5, \"cm\"),\n    aspect.ratio = 1\n  ) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\n# switch to full dataset\nDefaultAssay(object) <- \"Spatial.008um\"\nIdents(object) <- \"seurat_cluster.projected\"\n\np5 <- DimPlot(object, \n              reduction = \"full.umap.sketch\", \n              label = T, \n              raster = F) +\n  scale_color_manual(values = distinct_palette) +\n  ggtitle(\"Projected clustering (full dataset)\") +\n  theme(\n    legend.key.size = unit(0.5, \"cm\"),\n    aspect.ratio = 1\n  ) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nfinal_plot <- wrap_plots(p4, p5, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n### Comparison\n\nNo we can compare the Banksy spatially aware clustering with the non-spatial aware 'default' Seurat clustering:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDefaultAssay(object) <- \"Spatial.008um\"\nIdents(object) <- \"seurat_cluster.projected\"\n\np6 <- SpatialDimPlot(object,\n  group.by = \"seurat_cluster.projected\",\n  pt.size.factor = pt_size_factor,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_fill_manual(values = distinct_palette) +\n  ggtitle(\"Projected clustering (full dataset)\") +\n  theme(legend.key.size = unit(0.5, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nfinal_plot <- wrap_plots(p2, p3, p6, p5, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\nLet's compare the cell-to-cell overlap in Banksy versus conventional clustering assignments\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Here we create a cross-table of each cluster type\nprop_table <- prop.table(\n  table(\n    \"Banksy\" = object$banksy_cluster,\n    \"Sketched\" = object$seurat_cluster.projected\n  ),\n  margin = 1\n)\nComplexHeatmap::Heatmap(prop_table,\n  name = \"Proportion\",\n  column_title = \"Sketched\",\n  column_title_side = \"bottom\",\n  row_title = \"Banksy\",\n  row_title_side = \"right\",\n  col = viridis::cividis(10)\n)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-23-1.png){width=288}\n:::\n:::\n\n\n::: callout-note\nWe can see that there is some overlap, but many differences as well. Why is this?\n\nIt is important to consider what we want out of spatial clustering:\n\n-   Do we want discrete cell type clusters?\n-   Do we want clusters of cell neighborhoods?\n\nMany spatially aware clustering methods are being published as the field is relatively new, and technologies are constantly being improved. As such, there is not yet a gold standard approach to solving these problems. As you can appreciate, `Banksy` seems to preserve more of the tissue architecture, whereas the conventional `Seurat` approach does not utilize the spatial information. How exactly you process and interpret your own data will depend on the types of questions you seek to answer.\n:::\n\n## Cell type identification\n\n### Denovo marker identification\n\nNow we'd like to identify the constituent cell types in our sample. This analysis proceeds according to the conventional workflow of selecting the clusters of interest, and running Seurat's `FindAllMarkers()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure the spatial count data is the active assay prior to proceeding\nDefaultAssay(object) <- \"Spatial.008um\"\n# Here we use the banksy clusters\nIdents(object) <- \"banksy_cluster\"\n\nbanksy_markers <- FindAllMarkers(object,\n  assay = \"Spatial.008um\",\n  only.pos = T,\n  logfc.threshold = 0.4,\n  min.pct = 0.1,\n  verbose = TRUE\n)\n```\n:::\n\n\nNow we can plot a heatmap of the top 10 markers per cluster using Seurat's `DoHeatmap()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_n_genes <- 5 # Select how many top genes to plot\n# Select the top markers by cluster\ntop_genes <- banksy_markers %>%\n  group_by(cluster) %>%\n  dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>%\n  slice_head(n = top_n_genes) %>%\n  ungroup()\n\n# Scale the data for these genes\nobject <- ScaleData(object, assay = \"Spatial.008um\", features = top_genes$gene)\n\n# Plot a heatmap using Seurat's DoHeatmap\np1 <- DoHeatmap(\n  # We subsample our object when we plot to 100 cells per\n  # banksy cluster, otherwise plot will not generate\n  object = subset(object, downsample = 100),\n  group.by = \"banksy_cluster\",\n  group.colors = distinct_palette,\n  assay = \"Spatial.008um\",\n  features = top_genes$gene,\n  raster = T,\n  size = 2.5\n) +\n  scale_fill_viridis_c()\np1\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-25-1.png){width=480}\n:::\n:::\n\n\nWe can also plot using Seurat's `DotPlot()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seurat's DotPlot function doesn't like duplicated genes across\ntop_n_genes <- 5 # Select how many top genes to plot\ntop_unique <- banksy_markers %>%\n  group_by(cluster) %>%\n  dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>%\n  slice_head(n = top_n_genes) %>%\n  ungroup() %>%\n  distinct(gene, .keep_all = T)\n\ntop_list <- split(top_unique$gene, top_unique$cluster)\n\np <- DotPlot(object, features = top_list, group.by = \"banksy_cluster\") +\n  scale_color_gradient2(low = \"blue\", high = \"red\") +\n  guides(x = guide_axis(angle = 90))\np\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-26-1.png){width=960}\n:::\n:::\n\n\n### Using curated celltype markers\n\nWe can also load a manually curated marker list for cell types\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarker_table <- read_excel(\"data/DCIS_genes.xlsx\")\nunique(marker_table$Cell.type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"CD8.T.cells\"         \"CD4.T.cells\"         \"NK.cells\"           \n [4] \"B.cell\"              \"Plasma\"              \"Mast.cells\"         \n [7] \"Macrophages\"         \"Monocytes\"           \"DCs\"                \n[10] \"Endothelial.cells\"   \"CAF\"                 \"Basal_Myoepithelial\"\n[13] \"Epithelial.cells\"    \"Fibroblasts\"         \"Adipocytes\"         \n[16] \"Tumor\"               \"Luminal.progenitor\"  \"Luminal.mature\"     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(marker_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 2\n  Gene  Cell.type  \n  <chr> <chr>      \n1 CD8B  CD8.T.cells\n2 CD8A  CD8.T.cells\n3 CD3E  CD8.T.cells\n4 CD3D  CD8.T.cells\n5 CD4   CD4.T.cells\n6 CD3E  CD4.T.cells\n```\n:::\n:::\n\n\nUsing this marker list, we add a score for each cell type for each cell using Seurat's AddModuleScore, assigning cell types based on the maximum score.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We format the markers into a list\nmarker_list <- split(marker_table$Gene, marker_table$Cell.type)\nhead(marker_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Adipocytes\n [1] \"PNPLA2\"  \"CAV1\"    \"FABP4\"   \"PPARG\"   \"CEBPA\"   \"LEP\"     \"CIDEA\"  \n [8] \"SHOX2\"   \"SLC7A10\" \"SLC36A2\" \"P2RX5\"  \n\n$B.cell\n[1] \"BANK1\" \"CD79A\" \"CD74\"  \"MS4A1\" \"MEF2C\" \"CD19\"  \"CD79B\"\n\n$Basal_Myoepithelial\n[1] \"KRT14\"    \"DST\"      \"MMP7\"     \"MIR205HG\" \"MT1X\"     \"OXTR\"     \"KRT17\"   \n[8] \"FST\"     \n\n$CAF\n[1] \"CFD\"   \"DCN\"   \"GSN\"   \"EBF1\"  \"PRKG1\"\n\n$CD4.T.cells\n[1] \"CD4\"  \"CD3E\" \"CD3D\" \"SELL\" \"CCR7\" \"IL7R\" \"TCF7\" \"LEF1\"\n\n$CD8.T.cells\n[1] \"CD8B\" \"CD8A\" \"CD3E\" \"CD3D\"\n```\n:::\n:::\n\n\nNow we loop through each cell type within this list, and run Seurat's `AddModuleScore()` to add a signature score for each cell type to the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add module scores to the Seurat object based on marker genes\nfor (cell_type in names(marker_list)) {\n  object <- AddModuleScore(\n    object = object,\n    features = list(marker_list[[cell_type]]),\n    name = paste0(cell_type, \"_score\")\n  )\n}\n\n# AddModuleScore appends '1' to the end of each signature\n# Here we just remove the '1' appended to the column names\ncolnames(object@meta.data) <- gsub(\n  \"_score1$\", \"_score\",\n  colnames(object@meta.data)\n)\n\n# Grep out the names of the signature score columns for later use\nscore_names <- grep(\n  pattern = \"_score\",\n  x = colnames(object@meta.data),\n  value = T\n)\n```\n:::\n\n\nNow we can see we've added these signature scores to our objects metadata slot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject@meta.data[,score_names] %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      Adipocytes_score B.cell_score Basal_Myoepithelial_score\ns_008um_00594_00250-1      -0.04843953  -0.05159478               -0.08651620\ns_008um_00549_00222-1      -0.04485982  -0.05245652               -0.12322605\ns_008um_00543_00215-1      -0.05486628  -0.03945521               -0.13809411\ns_008um_00623_00165-1      -0.02630046  -0.01333380               -0.08457084\ns_008um_00622_00168-1      -0.02800082  -0.06598156               -0.11589853\ns_008um_00554_00215-1      -0.05000127  -0.03848164               -0.12308840\n                        CAF_score CD4.T.cells_score CD8.T.cells_score\ns_008um_00594_00250-1 -0.06500176       -0.07717423        0.00000000\ns_008um_00549_00222-1 -0.11179067       -0.04862343        0.00000000\ns_008um_00543_00215-1 -0.13263827       -0.08021617       -0.01345287\ns_008um_00623_00165-1 -0.10047016       -0.03276049        0.00000000\ns_008um_00622_00168-1 -0.12828592       -0.06733268        0.00000000\ns_008um_00554_00215-1 -0.12186553       -0.05697462        0.00000000\n                        DCs_score Endothelial.cells_score\ns_008um_00594_00250-1 -0.02356162            -0.015707745\ns_008um_00549_00222-1 -0.02395514            -0.007985048\ns_008um_00543_00215-1 -0.02453098            -0.023165847\ns_008um_00623_00165-1 -0.02740095            -0.018267301\ns_008um_00622_00168-1 -0.05844954            -0.021918579\ns_008um_00554_00215-1 -0.04518844            -0.037657037\n                      Epithelial.cells_score Fibroblasts_score\ns_008um_00594_00250-1             -0.2349866        -0.1335624\ns_008um_00549_00222-1             -0.1808460        -0.1159445\ns_008um_00543_00215-1              1.0962730        -0.1561470\ns_008um_00623_00165-1             -0.1161800         0.4069038\ns_008um_00622_00168-1              0.9965739        -0.1510347\ns_008um_00554_00215-1             -0.1991884        -0.1534404\n                      Luminal.mature_score Luminal.progenitor_score\ns_008um_00594_00250-1            0.8871498               0.48557773\ns_008um_00549_00222-1           -0.1930754              -0.06402006\ns_008um_00543_00215-1            0.3988119               0.57591030\ns_008um_00623_00165-1           -0.1037248              -0.04760308\ns_008um_00622_00168-1            1.5571822               0.69987994\ns_008um_00554_00215-1            1.5981126               0.55747085\n                      Macrophages_score Mast.cells_score Monocytes_score\ns_008um_00594_00250-1       -0.04674924      0.000000000      0.00000000\ns_008um_00549_00222-1       -0.04158879      0.000000000     -0.01330841\ns_008um_00543_00215-1       -0.08618247      0.000000000      0.00000000\ns_008um_00623_00165-1       -0.02038761     -0.009358249      0.00000000\ns_008um_00622_00168-1       -0.07711824      0.000000000     -0.03653096\ns_008um_00554_00215-1       -0.03463650     -0.007716606      0.00000000\n                      NK.cells_score Plasma_score Tumor_score\ns_008um_00594_00250-1   -0.003663187  -0.07951479 -0.29917351\ns_008um_00549_00222-1    0.000000000  -0.06273966  0.14807209\ns_008um_00543_00215-1    0.000000000  -0.06618813 -0.30683841\ns_008um_00623_00165-1    0.000000000  -0.04012699 -0.14184684\ns_008um_00622_00168-1    0.000000000  -0.04793996  0.09698491\ns_008um_00554_00215-1    0.000000000  -0.06014892 -0.29844976\n```\n:::\n:::\n\n\nNow we ask, for each cell, what is the maximum scoring cell signature? Assuming this score is above a lower threshold, we assign the cell to that type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify the cell type for each cell based on the highest module score\nobject$cell_type <- apply(\n  X = object@meta.data[, grep(\"_score$\", colnames(object@meta.data))],\n  MARGIN = 1,\n  FUN = function(scores) {\n    # If the maximum score is <0.05 we don't assign a celltype\n    if (max(scores) < 0.05) {\n      return(\"Other\")\n    } else {\n      return(names(scores)[which.max(scores)])\n    }\n  }\n)\n\n# Clean up the '_score' suffix from the cell_type column\nobject@meta.data[[\"cell_type\"]] <- gsub(\"_score\", \"\", object@meta.data[[\"cell_type\"]])\n\n# Convert to a factor, ordered by our cell type color ordering\nobject$cell_type <- factor(object$cell_type, levels = names(celltype_cols))\n```\n:::\n\n\nNow we can plot these cell type assignments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIdents(object) <- \"cell_type\"\n\np1 <- SpatialDimPlot(object,\n  group.by = \"cell_type\",\n  pt.size.factor = pt_size_factor,\n  label = F,\n  label.size = 3,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_fill_manual(values = celltype_cols) +\n  ggtitle(\"Major Cell Types\") +\n  theme(legend.key.size = unit(0.1, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 3)))\n\np2 <- DimPlot(object,\n  reduction = \"umap.banksy\",\n  label = F,\n  pt.size = 0.05,\n  raster = F # For large datasets set to T\n) +\n  scale_color_manual(values = celltype_cols) +\n  ggtitle(\"Major Cell Types\") +\n  theme(\n    legend.key.size = unit(0.2, \"cm\"),\n    aspect.ratio = 1\n  )\n\nfinal_plot <- wrap_plots(p1, p2, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-33-1.png){width=960}\n:::\n:::\n\n\nWe can look at the proportion of cell types within each Banksy cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject@meta.data %>%\n  ggplot(aes(x = banksy_cluster)) +\n  geom_bar(aes(fill = cell_type), position = \"fill\") +\n  scale_fill_manual(values = celltype_cols) +\n  theme_classic() +\n  guides(fill = guide_legend(keywidth = 0.5, keyheight = 0.5)) +\n  labs(y = \"Proportion\", fill = \"Cell Type\")\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\nRemember these are cell neighborhood clusters, and as such contain a mixture of different cell types\n:::\n\nLet's plot the raw signature values over each assigned cell type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelltypes_to_plot <- names(celltype_cols)\ncelltypes_to_plot <- celltypes_to_plot[celltypes_to_plot != \"Other\"]\ncelltype_score_vlnplots <- VlnPlot(\n  object,\n  features = paste0(celltypes_to_plot, \"_score\"),\n  pt.size = 0,\n  group.by = \"cell_type\",\n  cols = celltype_cols,\n  sort = T,\n  combine = F # This will return a list instead of a patchwork\n)\n\nnames(celltype_score_vlnplots) <- celltypes_to_plot\n\ncelltype_score_umapplots <- FeaturePlot(\n  object = object,\n  features = paste0(celltypes_to_plot, \"_score\"),\n  reduction = \"umap.banksy\",\n  pt.size = 0.05,\n  combine = F,\n  # This will compress the color scale to bring out cells\n  min.cutoff = \"q1\",\n  max.cutoff = \"q99\",\n  # Bring the points with higher values on top\n  order = T,\n  raster = F # For large datasets set to T\n)\nnames(celltype_score_umapplots) <- celltypes_to_plot\n```\n:::\n\n\nNow we can loop through and plot the signatures as violins and atop the Banksy UMAP\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (ct in celltypes_to_plot) {\n  p1 <- celltype_score_umapplots[[ct]] +\n    scale_color_viridis_c()\n\n  p2 <- celltype_score_vlnplots[[ct]] +\n    NoLegend()\n\n  pcomb <- free(p1, type = \"label\", side = \"b\") +\n    p2 + plot_layout(nrow = 1, widths = c(1, 2.5))\n  print(pcomb)\n}\n```\n:::\n\n\n::: panel-tabset\n\n\n```{.r .cell-code}\nfor (ct in as.character(celltypes_to_plot)) {\n  cat(\"## \", ct, \"\\n\\n\")\n\n  p1 <- celltype_score_umapplots[[ct]]\n  p1$scales$scales <- list()\n  p1 <- p1 +\n    scale_color_viridis_c()\n\n  p2 <- celltype_score_vlnplots[[ct]] +\n    NoLegend()\n\n  pcomb <- free(p1, type = \"label\", side = \"b\") +\n    p2 + plot_layout(nrow = 1, widths = c(1, 2.5))\n\n  print(pcomb)\n\n  cat(\"\\n\\n\")\n}\n```\n\n##  CD8.T.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-1.png){width=960}\n\n##  CD4.T.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-2.png){width=960}\n\n##  B.cell \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-3.png){width=960}\n\n##  Plasma \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-4.png){width=960}\n\n##  Monocytes \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-5.png){width=960}\n\n##  Macrophages \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-6.png){width=960}\n\n##  DCs \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-7.png){width=960}\n\n##  Endothelial.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-8.png){width=960}\n\n##  CAF \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-9.png){width=960}\n\n##  Basal_Myoepithelial \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-10.png){width=960}\n\n##  Epithelial.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-11.png){width=960}\n\n##  Fibroblasts \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-12.png){width=960}\n\n##  Luminal.progenitor \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-13.png){width=960}\n\n##  Luminal.mature \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-14.png){width=960}\n\n##  Tumor \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-15.png){width=960}\n\n##  NK.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-16.png){width=960}\n\n##  Mast.cells \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-17.png){width=960}\n\n##  Adipocytes \n\n![](01_spatial_intro_files/figure-html/unnamed-chunk-37-18.png){width=960}\n\n:::\n\nWe can also use `lapply()` to loop through each cell type and plot it on the image\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelltype_plots <- lapply(X = celltypes_to_plot, FUN = function(ct) {\n  # Subset object for the current cell type\n  subsetobject <- object[, object$cell_type == ct]\n\n  # Generate the SpatialDimPlot\n  p <- SpatialDimPlot(\n    subsetobject,\n    group.by = \"cell_type\",\n    pt.size.factor = pt_size_factor,\n    label = FALSE,\n    image.alpha = 0.2,\n    alpha = c(1, 0.2),\n    cols = celltype_cols\n  ) +\n    NoLegend() +\n    ggtitle(ct) +\n    theme(plot.title = element_text(hjust = 0.5, face = \"bold\", size = 12))\n  return(p)\n})\n\nnames(celltype_plots) <- celltypes_to_plot\n```\n:::\n\n\nNow we have a list of cell type specific plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelltype_plots$Fibroblasts + celltype_plots$Luminal.mature\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-39-1.png){width=480}\n:::\n:::\n\n\nWe can wrap them all in a single patchwork:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine all plots into a grid\nfinal_plot <- wrap_plots(celltype_plots, ncol = 5)\n\n# Display the final combined plot\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-40-1.png){width=960}\n:::\n:::\n\n\n## Advanced Analysis\n\n### Pseudotime\n\nNow we will subset for only epithelial cells and run pseudotime analysis using [`Monocle3`](https://cole-trapnell-lab.github.io/monocle3/)\n\n#### Subset for epithelial cells\n\nSubset the data to the cell types of interest\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset for epithelial cells only\nobject_epi <- subset(object, idents = c(\"Luminal.progenitor\", \"Luminal.mature\", \"Tumor\", \"Basal_Myoepithelial\"))\n\nDefaultAssay(object_epi) <- \"Spatial.008um\"\n```\n:::\n\n\nBecause we've subset, we'll reperform `FindVariableFeatures()`, as the features that are variable across epithelial cells only may differ from those in the entire dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject_epi <- FindVariableFeatures(object_epi)\nobject_epi\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n40170 features across 10352 samples within 3 assays \nActive assay: Spatial.008um (18085 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 2 other assays present: BANKSY, sketch\n 6 dimensional reductions calculated: pca.banksy, umap.banksy, pca.sketch, umap.sketch, full.pca.sketch, full.umap.sketch\n 1 spatial field of view present: slice1.008um\n```\n:::\n:::\n\n\nRerun the Banksy workflow on this subset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run Banksy\nobject_epi <- RunBanksy(object_epi,\n  lambda = 0.8,\n  verbose = TRUE,\n  assay = \"Spatial.008um\",\n  slot = \"data\",\n  features = \"variable\",\n  k_geom = 24\n)\n\nobject_epi <- RunPCA(object_epi,\n  assay = \"BANKSY\",\n  reduction.name = \"pca.banksy\",\n  features = rownames(object_epi),\n  npcs = 20\n)\n\nElbowPlot(object_epi, reduction = \"pca.banksy\")\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n\n```{.r .cell-code}\nobject_epi <- FindNeighbors(object_epi,\n  reduction = \"pca.banksy\",\n  dims = 1:15\n)\n\nobject_epi <- FindClusters(object_epi,\n  cluster.name = \"banksy_cluster\",\n  resolution = 0.2\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10352\nNumber of edges: 249083\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9216\nNumber of communities: 11\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\nobject_epi <- RunUMAP(object_epi,\n  reduction = \"pca.banksy\",\n  reduction.name = \"umap.banksy\",\n  return.model = T,\n  dims = 1:15\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- SpatialDimPlot(object_epi,\n  group.by = \"banksy_cluster\",\n  pt.size.factor = pt_size_factor,\n  label = F,\n  label.size = 5,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_fill_manual(values = distinct_palette) +\n  ggtitle(\"Banksy Neighborhood Clustering\") +\n  theme(legend.key.size = unit(0.5, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\n# Idents(object) <- \"banksy_cluster\"\n\np3 <- DimPlot(object_epi,\n  group.by = \"banksy_cluster\",\n  reduction = \"umap.banksy\",\n  label = TRUE,\n  label.size = 2,\n  raster = FALSE\n) +\n  scale_color_manual(values = distinct_palette) +\n  ggtitle(\"Banksy Neighborhood Clustering\") +\n  theme(legend.key.size = unit(0.5, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nfinal_plot <- wrap_plots(p2, p3, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-44-1.png){width=960}\n:::\n:::\n\n\n#### Run `monocle3`\n\nNow we run the [`monocle3`](https://cole-trapnell-lab.github.io/monocle3/) pseudotime analysis tool. First we create the `monocle3` specific `cell_data_set` object. See the [documentation](https://cole-trapnell-lab.github.io/monocle3/docs/getting_started/) for more information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(monocle3)\n\n# Create Monocle CDS\nexpression_matrix <- object_epi@assays[[\"Spatial.008um\"]]@layers[[\"counts\"]]\ncolnames(expression_matrix) <- colnames(object_epi@assays[[\"Spatial.008um\"]])\nrownames(expression_matrix) <- rownames(object_epi@assays[[\"Spatial.008um\"]])\n\nmetadata <- object@meta.data[colnames(expression_matrix), ]\n\n# Monocle3 complains otherwise\nmetadata$sample_name <- NULL\n\ngene_annotation <- data.frame(gene_short_name = rownames(expression_matrix))\nrownames(gene_annotation) <- rownames(expression_matrix)\n\ncds <- new_cell_data_set(expression_matrix,\n  cell_metadata = metadata,\n  gene_metadata = gene_annotation\n)\ncds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: cell_data_set \ndim: 18085 10352 \nmetadata(1): cds_version\nassays(1): counts\nrownames(18085): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(1): gene_short_name\ncolnames(10352): s_008um_00594_00250-1 s_008um_00549_00222-1 ...\n  s_008um_00603_00164-1 s_008um_00548_00195-1\ncolData names(31): orig.ident nCount_Spatial.008um ... cell_type\n  Size_Factor\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n:::\n:::\n\n\nNow, we run preprocessing, dimension reduction, cell clustering and learn the cell principal graph within the `monocle3` framework\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncds <- preprocess_cds(cds, num_dim = 10)\n\ncds <- reduce_dimension(cds)\n\ncds <- cluster_cells(cds,\n  reduction_method = \"UMAP\",\n  max_clusters = 6\n)\n\ncds <- learn_graph(cds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n\n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n:::\n\n\nLet's see what the UMAP looks like\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  # show_trajectory_graph = FALSE,\n  # label_groups_by_cluster = FALSE,\n  # label_branch_points = FALSE,\n  # label_principal_points = FALSE,\n  color_cells_by = \"cell_type\"\n)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds, color_cells_by = \"partition\")\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n\n\nWe define a function to identify the root principal points\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a helper function to identify the root principal points:\nget_earliest_principal_node <- function(\n    cds,\n    time_bin = c(\"Basal_Myoepithelial\", \"Luminal.progenitor\")) {\n  cell_ids <- which(colData(cds)[, \"cell_type\"] == time_bin)\n\n  closest_vertex <-\n    cds@principal_graph_aux[[\"UMAP\"]]$pr_graph_cell_proj_closest_vertex\n  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])\n  root_pr_nodes <-\n    igraph::V(principal_graph(cds)[[\"UMAP\"]])$name[as.numeric(names\n    (which.max(table(closest_vertex[cell_ids, ]))))]\n\n  root_pr_nodes\n}\ncds <- order_cells(cds, root_pr_nodes = get_earliest_principal_node(cds))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = \"pseudotime\",\n  label_cell_groups = FALSE,\n  label_leaves = FALSE,\n  label_branch_points = FALSE,\n  graph_label_size = 1.5\n)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = \"cluster\",\n  label_groups_by_cluster = F, # Ensures clusters are labeled\n  label_leaves = FALSE,\n  label_branch_points = FALSE,\n  group_label_size = 4\n)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate the plot as a real ggplot object\nplot_cells(\n  cds,\n  color_cells_by = \"banksy_cluster\",\n  label_groups_by_cluster = FALSE,\n  label_leaves = FALSE,\n  label_branch_points = FALSE,\n  group_label_size = 4\n)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = \"pseudotime\",\n  label_groups_by_cluster = F,\n  label_leaves = F,\n  label_branch_points = F\n) +\n  facet_wrap(~cell_type, nrow = 2) +\n  theme(legend.position = \"right\") +\n  scale_color_gradientn(\n    colors = c(\"blue3\", \"palegreen3\", \"yellow\", \"tomato\", \"firebrick\")\n  )\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = \"pseudotime\",\n  label_groups_by_cluster = F,\n  label_leaves = F,\n  label_branch_points = F\n) +\n  facet_wrap(~banksy_cluster, nrow = 4) +\n  theme(legend.position = \"right\") +\n  scale_color_gradientn(\n    colors = c(\"blue3\", \"palegreen3\", \"yellow\", \"tomato\", \"firebrick\")\n  )\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = c(\"banksy_cluster\"),\n  label_cell_groups = FALSE,\n  label_groups_by_cluster = F,\n  label_leaves = F,\n  label_branch_points = F\n) +\n  theme(legend.position = \"right\") + \n  scale_color_manual(values = distinct_palette)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_colors <- c(\n  \"Basal_Myoepithelial\" = \"mediumseagreen\",\n  \"Luminal.progenitor\" = \"navy\",\n  \"Luminal.mature\" = \"#bcbd22\",\n  \"Tumor\" = \"magenta\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(cds,\n  color_cells_by = c(\"cell_type\"),\n  label_cell_groups = FALSE,\n  label_groups_by_cluster = F,\n  label_leaves = F,\n  label_branch_points = F\n) +\n  theme(legend.position = \"right\") + \n  scale_color_manual(values = cluster_colors)\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\nAdd this back to our original object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclusters <- cds@clusters@listData[[\"UMAP\"]][[\"clusters\"]]\npseudotime <- cds@principal_graph_aux@listData[[\"UMAP\"]][[\"pseudotime\"]]\n\nobject_epi <- AddMetaData(object_epi,\n  metadata = clusters,\n  col.name = \"monocle3_cluster\"\n)\nobject_epi <- AddMetaData(object_epi,\n  metadata = pseudotime,\n  col.name = \"monocle3_pseudotime\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Plot\nDefaultAssay(object) <- \"Spatial.008um\"\nIdents(object) <- \"monocle3_cluster\"\n\nsummary(object_epi$monocle3_pseudotime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   6.525  12.327     Inf     Inf     Inf \n```\n:::\n\n```{.r .cell-code}\nmax_finite <- max(object_epi$monocle3_pseudotime[is.finite(object_epi$monocle3_pseudotime)], na.rm = TRUE)\n\nobject_epi$monocle3_pseudotime[is.infinite(object_epi$monocle3_pseudotime)] <- max_finite\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFeaturePlot(object_epi, features = \"monocle3_pseudotime\") +\n  scale_color_gradientn(\n    colors = c(\"blue3\", \"palegreen3\", \"yellow\", \"tomato\", \"firebrick\"),\n    name = \"monocle3_pseudotime\"\n  ) +\n  ggtitle(\"Monocle Pseudotime\") +\n  theme(\n    legend.position = \"right\",\n    legend.key.size = unit(0.4, \"cm\"),\n    plot.title = element_text(size = 14, family = \"Arial\"),\n    legend.text = element_text(size = 10, family = \"Arial\"),\n    axis.text = element_text(size = 12, family = \"Arial\"),\n    legend.title = element_text(size = 10, family = \"Arial\"),\n    axis.title = element_text(size = 12, family = \"Arial\")\n  )\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate the SpatialDimPlot\nplots <- SpatialFeaturePlot(\n  object_epi,\n  features = \"monocle3_pseudotime\",\n  pt.size.factor = pt_size_factor,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_color_gradientn(colors = c(\"blue3\", \"palegreen3\", \"yellow\", \"tomato\", \"firebrick\")) +\n  ggtitle(\"Monocle Pseudotime\") +\n  theme(\n    legend.position = \"right\",\n    legend.key.size = unit(0.5, \"cm\")\n  ) +\n  labs(color = \"pseudotime\") +\n  guides(color = guide_colorbar(barwidth = 0.5, barheight = 4))\nplots\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDefaultAssay(object) <- \"Spatial.008um\"\nIdents(object) <- \"monocle3_cluster\"\n\np2 <- SpatialDimPlot(object_epi,\n  group.by = \"monocle3_cluster\",\n  pt.size.factor = pt_size_factor,\n  label = F,\n  label.size = 5,\n  image.alpha = 0.2,\n  alpha = c(1, 1)\n) +\n  scale_fill_manual(values = distinct_palette) +\n  ggtitle(\"Monocle3 Clustering\") +\n  theme(legend.key.size = unit(0.5, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\n\np3 <- DimPlot(object_epi,\n  reduction = \"umap.banksy\",\n  label = TRUE,\n  label.size = 2,\n  raster = FALSE\n) +\n  scale_color_manual(values = distinct_palette) +\n  ggtitle(\"Monocle3 Clustering\") +\n  theme(legend.key.size = unit(0.5, \"cm\")) +\n  guides(fill = guide_legend(override.aes = list(size = 5)))\n\nfinal_plot <- wrap_plots(p2, p3, ncol = 2)\nfinal_plot\n```\n\n::: {.cell-output-display}\n![](01_spatial_intro_files/figure-html/unnamed-chunk-62-1.png){width=960}\n:::\n:::\n\n\nTo extract csv files of the cell types and clusters to add to Loupe Browser\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutdir = \"data/\"\nsample_name = \"Visium_DCIS\"\n\nmetadata <- object@meta.data[, c(\"seurat_cluster.projected\", \"banksy_cluster\", \"cell_type\")] %>%\n  tibble::rownames_to_column(var = \"CellID\")\n\nexport_cluster_proj <- metadata[, c(\"CellID\", \"seurat_cluster.projected\")]\nexport_cluster_banksy <- metadata[, c(\"CellID\", \"banksy_cluster\")]\nexport_celltype <- metadata[, c(\"CellID\", \"cell_type\")]\n\n# Write to CSV\nwrite.csv(export_cluster_proj, file = file.path(outdir, paste0(sample_name, \"_cluster_proj.csv\")), row.names = FALSE)\nwrite.csv(export_cluster_banksy, file = file.path(outdir, paste0(sample_name, \"_cluster_banksy.csv\")), row.names = FALSE)\nwrite.csv(export_celltype, file = file.path(outdir, paste0(sample_name, \"_cell_type.csv\")), row.names = FALSE)\n```\n:::\n",
    "supporting": [
      "01_spatial_intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}