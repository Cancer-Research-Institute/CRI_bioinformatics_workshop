{
  "hash": "547bf5ee21703f851bafca5468394828",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Basic plotting and statistics\"\nformat:\n  html:\n    code-link: true\n    other-links:\n      - text: Lecture Slides\n        href: https://github.com/Cancer-Research-Institute/CRI_bioinformatics_workshop/blob/eeacedb409bb9a9766e9c99a348c5fbc3a0074ed/course/slides/CRI%20Bioinformatics%20Bootcamp%202025%20Day%201PM.pdf\nengine: knitr\n---\n\n\n## Long and Wide Data Formats\n\nLong and wide data formats are two common ways of structuring data, each with its own advantages and use cases.\n\n### Long Format\n\nIn the long format, also known as the \"tidy\" format, each observation is represented by a single row in the dataset. This format is characterized by having:\n\n- Multiple rows, each corresponding to a single observation or measurement.\n- One column for the variable being measured.\n- Additional columns to store metadata or grouping variables.\n\n**Advantages**:\n\n- Facilitates easy analysis and manipulation, especially when using tools like Tidyverse packages in R.\n- Suitable for data that follow the \"one observation per row\" principle, such as time series or longitudinal data.\n\n### Wide Format\n\nIn the wide format, each observation is represented by a single row, but with multiple columns corresponding to different variables. This format is characterized by:\n\n- One row per observation.\n- Each variable is represented by a separate column.\n\n**Advantages**:\n\n- Can be easier to understand for simple datasets with few variables.\n- May be more convenient for certain types of analysis or visualization.\n\n### Choosing Between Long and Wide Formats\n\nThe choice between long and wide formats depends on factors such as the nature of the data, the analysis tasks, and personal preference. Long format is often preferred for its flexibility and compatibility with modern data analysis tools, while wide format may be suitable for simpler datasets or specific analysis requirements.\n\n## Long to Wide\n\n```R\nlibrary(tidyr)\n\n# Example long format data\nlong_data <- data.frame(\n  Subject = c(\"A\", \"A\", \"B\", \"B\"),\n  Time = c(1, 2, 1, 2),\n  Measurement = c(10, 15, 12, 18)\n)\n\n# Convert long format data to wide format\nwide_data <- spread(long_data, key = Time, value = Measurement)\n\n# View the wide format data\nprint(wide_data)\n```\n\n## Wide to Long\n\n```R\nlibrary(tidyr)\n\n# Example wide format data\nwide_data <- data.frame(\n  Subject = c(\"A\", \"B\"),\n  Time1 = c(10, 12),\n  Time2 = c(15, 18)\n)\n\n# Convert wide format data to long format\nlong_data <- gather(wide_data, key = Time, value = Measurement, -Subject)\n\n# View the long format data\nprint(long_data)\n```\n\n# Merging Data\n\nMerging allows combining data from different sources. This is common in analyzing biological data.\n\n## Joins and Merging of Data in Tidyverse\n\nJoins and merging are common operations used to combine multiple datasets based on common variables or keys. In Tidyverse, these operations are typically performed using functions from the `dplyr` package.\n\n### Types of Joins:\n\n![Types of Joins](join_diagram.png)\n\n#### Inner Join (`inner_join()`):\nAn inner join combines rows from two datasets where there is a match based on a common key, retaining only the rows with matching keys from both datasets.\n\n#### Left Join (`left_join()`):\nA left join combines all rows from the first (left) dataset with matching rows from the second (right) dataset based on a common key. If there is no match in the second dataset, missing values are filled in.\n\n#### Right Join (`right_join()`):\nSimilar to a left join, but it retains all rows from the second (right) dataset and fills in missing values for non-matching rows from the first (left) dataset.\n\n#### Full Join (`full_join()`):\nA full join combines all rows from both datasets, filling in missing values where there are no matches.\n\n#### Semi-Join (`semi_join()`):\nA semi-join returns only rows from the first dataset where there are matching rows in the second dataset, based on a common key.\n\n#### Anti-Join (`anti_join()`):\nAn anti-join returns only rows from the first dataset that do not have matching rows in the second dataset, based on a common key.\n\n### Merging Data:\n\n#### Merge (`merge()`):\nThe `merge()` function is a base R function used to merge datasets based on common columns or keys. It performs similar operations to joins in `dplyr`, but with slightly different syntax and behavior.\n\n### Example:\n\n```R\nlibrary(dplyr)\n\n# Example datasets\ndf1 <- data.frame(ID = c(1, 2, 3), Name = c(\"Alice\", \"Bob\", \"Charlie\"))\ndf2 <- data.frame(ID = c(2, 3, 4), Score = c(85, 90, 95))\n\n# Inner join\ninner_merged <- inner_join(df1, df2, by = \"ID\")\n\n# Left join\nleft_merged <- left_join(df1, df2, by = \"ID\")\n\n# Right join\nright_merged <- right_join(df1, df2, by = \"ID\")\n\n# Full join\nfull_merged <- full_join(df1, df2, by = \"ID\")\n\n# Semi-join\nsemi_merged <- semi_join(df1, df2, by = \"ID\")\n\n# Anti-join\nanti_merged <- anti_join(df1, df2, by = \"ID\")\n```\n\n\n# Plotting\n\n## `ggplot2`\n\nThe core idea behind ``ggplot2`` is the concept of a \"grammar of graphics\". This concept provides a systematic way to describe and build graphical presentations such as charts and plots. The grammar itself is a set of independent components that can be composed in many different ways. This grammar includes elements like:\n\n - Data: The raw data that you want to visualize.\n - Aesthetics (`aes`): Defines how data are mapped to color, size, shape, and other visual properties.\n - Geometries (`geom`): The geometric objects in a plot—lines, points, bars, etc.\n - Scales: Transformations applied to data before it is visualized, including scales for colors, sizes, and shapes.\n - Coordinate systems: The space in which data is plotted.\n - Facets: Used for creating plots with multiple panels (small multiple plots).\n - Statistical transformations (stat): Summary statistics that can be applied to data before it is visualized, such as counting or averaging.\n - Themes: Visual styles and layout configurations for the plot.\n\n\nHere’s how you generally use ggplot2 to create a plot:\n\n - Start with `ggplot()`: Set up the data and, optionally, define default mappings between variables and their aesthetics.\n - Add layers: Add layers to the plot using geom_ functions, such as `geom_point()` for scatter plots, `geom_line()` for line graphs, and so on.  \n - Adjust the scales: Customize the scales used for aesthetics such as color, size, and x-y coordinates.\n - Modify the coordinate system: Choose a coordinate system.\n - Add facets: If necessary, add facets to create a multi-panel plot.\n - Apply a theme: Customize the appearance of the plot using themes.\n\n```R\nlibrary(ggplot2)\n\n# Sample data\ndf <- data.frame(\n  x = rnorm(100),\n  y = rnorm(100),\n  group = factor(rep(1:2, each = 50))\n)\n\n# Creating a scatter plot\nggplot(df, aes(x = x, y = y, color = group)) + \n  geom_point() +\n  theme_minimal() +\n  labs(title = \"Scatter Plot Example\", x = \"X Axis\", y = \"Y Axis\")\n```\n![Scatter](scatter.png)\n\n## Histogram\n\nLet's simulate some TCR clonotype data. We will create a dataset where each TCR has a randomly generated number of cells associated with it, representing the clone size. After generating the data, we'll use the hist() function from base R to plot a histogram of the clone sizes.\n\n```R\nlibrary(dplyr)\n\n# Step 1: Simulate data\nset.seed(123)  # Set seed for reproducibility\nnum_clonotypes <- 100  # Specify the number of different clonotypes\n\n# Create a data frame with random cell counts for each clonotype\ntcr_data <- tibble(\n  clonotype = paste(\"TCR\", seq_len(num_clonotypes), sep=\"\"),\n  cell_count = sample(1:1000, num_clonotypes, replace=TRUE)  # Random cell counts between 1 and 1000\n)\n\n# Step 2: Create a histogram of clone sizes\nhist(tcr_data$cell_count, \n     breaks=20,  # You can adjust the number of breaks to change bin sizes\n     col=\"skyblue\", \n     main=\"Histogram of TCR Clone Sizes\", \n     xlab=\"Clone Size (Number of Cells)\", \n     ylab=\"Frequency\")\n```\n\n\nWe can perform the same task using ``ggplot2``:\n```R\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Step 1: Simulate data\nset.seed(123)  # Set seed for reproducibility\nnum_clonotypes <- 100  # Specify the number of different clonotypes\n\n# Create a data frame with random cell counts for each clonotype\ntcr_data <- tibble(\n  clonotype = paste(\"TCR\", seq_len(num_clonotypes), sep=\"\"),\n  cell_count = sample(1:1000, num_clonotypes, replace=TRUE)  # Random cell counts between 1 and 1000\n)\n\n# Step 2: Create a histogram using ggplot2\nggplot(tcr_data, aes(x = cell_count)) + \n  geom_histogram(bins = 20, fill = \"skyblue\", color = \"black\") + \n  theme_minimal() + \n  labs(\n    title = \"Histogram of TCR Clone Sizes\",\n    x = \"Clone Size (Number of Cells)\",\n    y = \"Frequency\"\n  ) + \n  theme(\n    plot.title = element_text(hjust = 0.5)  # Center the plot title\n  )\n```\n![Histogram](hist.png)\n\n## Boxplot\n\nLet's simulate some gene expression data for key CD8 T cell genes.\n\n```R\n# Define genes and number of cells\ngenes <- c(\"GZMB\", \"GZMA\", \"GNLY\", \"PRF1\", \"TOX\", \"ENTPD1\", \"LAG3\", \"HAVCR2\", \"TIGIT\", \"CXCL13\", \"IL7R\", \"SELL\", \"LEF1\", \"TCF7\")\nnum_cells <- 20\n\n# Parameters for negative binomial\nsize <- 2  # Dispersion parameter\nmu_pre <- 20  # Mean for pre-treatment\nmu_post <- 30  # Mean for post-treatment\n\n# Simulate gene expression data\nset.seed(42)\npre_treatment <- sapply(rep(mu_pre, length(genes)), function(mu) rnbinom(num_cells, size, mu = mu))\npost_treatment <- sapply(rep(mu_post, length(genes)), function(mu) rnbinom(num_cells, size, mu = mu))\n\n# Ensure data frames have proper column names\ncolnames(pre_treatment) <- genes\ncolnames(post_treatment) <- genes\n\n# Format as data frame\npre_data <- as_tibble(pre_treatment) %>% \n  mutate(Treatment = \"Pre\") %>% \n  pivot_longer(cols = -Treatment, names_to = \"Gene\", values_to = \"Expression\")\n\npost_data <- as_tibble(post_treatment) %>% \n  mutate(Treatment = \"Post\") %>% \n  pivot_longer(cols = -Treatment, names_to = \"Gene\", values_to = \"Expression\")\n\n# Combine the datasets\ncombined_data <- bind_rows(pre_data, post_data)\n\n# Printing to see the combined data (optional)\nprint(combined_data)\n```\n\nNow let's use this data to build a boxplot of TOX expression pre and post treatment.\n\n```R\n# Filter data for the TOX gene\ntox_data <- combined_data %>% \n  filter(Gene == \"TOX\")\n\n# Plot\nggplot(tox_data, aes(x=Treatment, y=Expression, fill=Treatment)) +\n  geom_boxplot() +\n  labs(title=\"Expression of TOX pre and post treatment\", x=\"Treatment Condition\", y=\"Expression Level\") +\n  theme_minimal() +\n  scale_fill_brewer(palette=\"Pastel1\")  # Enhance aesthetics with color\n```\n\n![Boxplot of TOX Expression](tox_expression.png)\n\n## Violin plot\n\nSame thing a violin plot.\n```R\nlibrary(ggplot2)\n\n# Filter data for the TOX gene\ntox_data <- combined_data %>% \n  filter(Gene == \"TOX\")\n\n# Create the violin plot\nggplot(tox_data, aes(x=Treatment, y=Expression, fill=Treatment)) +\n  geom_violin(trim=FALSE) +  # Trim set to FALSE to show the full range of data\n  labs(title=\"Expression of TOX pre and post treatment\", x=\"Treatment Condition\", y=\"Expression Level\") +\n  theme_minimal() +\n  scale_fill_brewer(palette=\"Pastel1\") +\n  geom_boxplot(width=0.1, fill=\"white\")  # Overlay boxplot to show median and quartiles\n```\n![Violin of TOX Expression](tox_violin.png)\n\n# Statistics\n\n## t-Test\nA t-test could be used to compare the means of two groups, for example, the level of a specific immune marker in patients with and without a certain mutation.\n\n```R\n# Randomly generated sample data: Immune marker levels in two patient groups\ngroup1 <- rnorm(30, mean = 5, sd = 1.5) # Patients with a mutation\ngroup2 <- rnorm(30, mean = 4.5, sd = 1.2) # Patients without the mutation\n\n# Perform a t-test\ntest <- t.test(group1, group2)\n\n# Print the result\nprint(test)\n```\n\nOutput:\n```R\nWelch Two Sample t-test\n\ndata:  group1 and group2\nt = 0.83457, df = 49.381, p-value = 0.408\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.3593549  0.8699988\nsample estimates:\nmean of x mean of y \n 4.951171  4.695849 \n```\n\n## Fisher's Exact Test\n\nAssume you've identified a TCR clonotype and quantified the number of cells expressing this clonotype at two timepoints:\n\n - Timepoint 1 (Pre-treatment): `X` number of cells\n - Timepoint 2 (Post-treatment): `Y` number of cells\n\nYou also need the total number of cells sequenced at each timepoint to complete the contingency table for the Fisher's Exact Test. Let's say:\n\n - Total cells at Timepoint 1: `N_pre`\n - Total cells at Timepoint 2: `N_post`\n\n ```R\n X <- 20\n Y <- 300\n \n N_pre <- 2450\n N_post <- 3001\n \n# Number of cells with the specific clonotype at each timepoint\ncells_with_clone <- c(X, Y)  \n\n# Number of cells without the clonotype (total cells minus cells with the clonotype)\ncells_without_clone <- c(N_pre - X, N_post - Y)\n\n# Create the contingency table\ndata <- matrix(c(cells_with_clone, cells_without_clone), ncol = 2,\n               dimnames = list(c(\"With Clone\", \"Without Clone\"),\n                               c(\"Pre-Treatment\", \"Post-Treatment\")))\n\n# Perform Fisher's Exact Test\ntest <- fisher.test(data)\n\n# Print the result\nprint(test)\n ```\n \nOutput:\n```R\n\tFisher's Exact Test for Count Data\n\ndata:  data\np-value < 2.2e-16\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.04445414 0.11701865\nsample estimates:\nodds ratio \n0.07410471 \n```\n\n\n\n - The matrix data has two rows (\"With Clone\" and \"Without Clone\") and two columns (\"Pre-Treatment\" and \"Post-Treatment\").\nThis matrix is filled with the counts of cells with and without the specific TCR clonotype at each timepoint.\n - `fisher.test(data)` calculates whether the proportions of cells with the clonotype are significantly different between the two timepoints.\n - The output includes a p-value which indicates the probability that any observed difference in proportions occurred by chance.\n\n\n# Additional Exercises\n\n```R\n# Load the iris dataset (saved as iris in base R)\n\n# Create a scatter plot of sepal length vs sepal width colored by species where the point size is determined from petal length.\n# Hint: Look at size arguments for aes. \n# CODE YOUR ANSWER HERE\n\n# Add a legend to your scatter plot for the size of the points.\n# HINT: Look into the guides function and use guide_legend().\n# CODE YOUR ANSWER HERE\n\n# Create a histogram of the petal length by species with 20 bins and add transparency to the plot.\n# Hint: Look into the arguments for geom_hist\n# CODE YOUR ANSWER HERE\n\n# Create a density plot of the petal length colored by species.\n# HINT: Look up geom_density.\n# CODE YOUR ANSWER HERE\n\n# Create a 2 panel plot with a histogram and a scatter plot\n# HINT: use grid.arrange from the gridExtra package.\n# CODE YOUR ANSWER HERE\n\n# Combine the density and histogram plots\n# HINT: The histogram needs to be normalized to the density plot, look into \"..density..\".\n# CODE YOUR ANSWER HERE\n\n# Perform a t-test on sepal length between the species setosa and versicolor\n# HINT: Pull out the necessary values using subset\n# CODE YOUR ANSWER HERE\n\n# Perform linear regession on the sepal length vs petal length and summarize the results. \n# HINT: Look into the lm function\n# CODE YOUR ANSWER HERE\n\n# Plot the regression line over a scatter plot of sepal vs petal length. \n# HINT: Look into the geom_smooth\n# CODE YOUR ANSWER HERE\n\n```\n\n\n",
    "supporting": [
      "2_basicplotting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}